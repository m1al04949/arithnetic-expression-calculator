# arithnetic-expression-calculator
 Distributed arithmetic expression evaluator


 Запуск приложения:
 1. Необходимо склонировать репозиторий https://github.com/m1al04949/arithnetic-expression-calculator.
 2. Выполнить команды:
    docker-compose up -d (чтобы поднять базу данных)
    go run main.go (из точки входа в папке cmd)

Точка входа приложения в папке cmd/orchestrator. 

Конфигурация работы сервера и приложения в целом - config/config.yaml.


В форму "Введите выражение" отправляются POST запросом математические выражения, которые предварительно проходят валидацию. ВНИМАНИЕ! Валидация в приложении упрощенная, скобочки в выражения недопустимы. Тем не менее, приоритеты в вычислениях мат. операций, естественно, соблюдены.

После прохождения валидации выражение попадает в базу данных (таблица expresions), где ему присваивается идентификатор, а также приписывается время добавления выражения. В структуре таблицы также поле для самого выражения, его статус (доступны 3 статуса: "new", "in processing", "completed") и результат (с типом float64).

Логика вычисления происходит в горутине Processing функции RunServer. База данных по тикеру опрашивается на предмет появления в таблице expressions выражения со статусом "new" (период опрашивания задаётся через config). Если такое выражений найдено, то меняем его статус на "in processing" и отправляем на парсинг. Выражение парсим к виду префиксной записи, тем самым образуя стэк операций для вычисления.
ВНИМАНИЕ! В случае, если приложение прекратит своё выполнение (сервер упадёт), то при перезапуске сервера всем выражения из таблицы expressions со статусом "in processing" будет присвоен статус "new" и они повторно попадают под вычисление.

После парсинга выражение передаётся агенту, который запускает горутину для его вычисления, задействуя для этого одну из свободных у него вычислительных мощностей. Результат вычисления мы получаем через канал, таким образом, мы не ждём пока агент закончит своё вычисление, а заново опрашиваем базу данных на предмет новых выражений, парсим и отправляем агенту на свободную вычислительную мощность.

Интерфейс для пользователя реализован через html-странички. Предполагается, что навигация пользователя по приложения происходит посредством кнопок. Пользователю доступны кнопки:

 - "Отправить" - для отправки выражения на вычисление;

 - "Перейти на страницу настроек" - для того, чтобы получить или изменить время выполнения той или иной элементарной математической операции (ВНИМАНИЕ! После изменения значений времён и нажатия кнопки "Применить" время выполнения изменённой операции будет применено в том числе к выражению, находящемуся в статусе "in processing" на следующей же итерации вычисления. Пример: запустили на вычисление выражение "1+1+1" с временем вычисления операции "+" - 20 секунд; если мы изменим время вычисления "+" = 1 секунда, то следующая операция сложения уже будет идти с таким интервалом, общее время вычисления примера в данном случае 20 + 1 = 21 секунда);

 - "Получить список выражений" - для отображения инофрмации о выражения в табличном ввиде (идентификатор, выражение, статус, результат);

 - "Получить количество вычислительных мощностей" - для получения информации о доступных для работы вычислительных мощностях (если вы отправили выражение на вычисление, но статус его по-прежнему "new", то либо тикер ещё не сработал и не опросил базу данных о вашем поступивщем выражении, либо нет доступных вычислительных мощностей для расчёта).


База данных реализована на PostgreSQL, поднимается посредством docker-compose. В остальном - Go. Роутер (маршутизатор запросов) реализовани при помощи go-chi; драйвер базы данных - pq; логирование с помощью стандартной библиотеки slog.


Если возникли проблемы с запуском, контакт для связи:
Телеграмм: @crashsmash.